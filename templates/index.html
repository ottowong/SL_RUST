<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>{{ name }}</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.7.1/jquery.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/socket.io/4.7.4/socket.io.js"></script>
    <script src="{{ url_for('static', filename='socket_client.js') }}"></script>
</head>
<body><div id = "main">
    <h1>{{ name }}</h1>
    <p>Current time: {{ time }}</p>
    <ul id="device_list">
        {% for i in range(0, len) %}
            <li id="{{ devices[i][0] }}">{{ devices[i][1] }}</li>
        {% endfor %}
    </ul>
    <canvas id="map_canvas"></canvas>
    <script>
        var canvas = document.getElementById('map_canvas');
        canvas.style.background = "#0b3a4a"
        var ctx = canvas.getContext('2d');
        var img = new Image();
        img.src = "{{ url_for('static', filename='map.png') }}";

        let cameraOffset = { x: window.innerWidth/2, y: window.innerHeight/2 }
        let cameraZoom = 1
        let MAX_ZOOM = 5
        let MIN_ZOOM = 0.1
        let SCROLL_SENSITIVITY = 0.001

        function draw()
        {
            canvas.width = window.innerWidth
            canvas.height = window.innerHeight
            
            // Translate to the canvas centre before zooming - so you'll always zoom on what you're looking directly at
            ctx.translate( window.innerWidth / 2, window.innerHeight / 2 )
            ctx.scale(cameraZoom, cameraZoom)
            ctx.translate( -window.innerWidth / 2 + cameraOffset.x, -window.innerHeight / 2 + cameraOffset.y )
            ctx.drawImage(img, 0,0);
            requestAnimationFrame( draw )
        }

        // Gets the relevant location from a mouse or single touch event
        function getEventLocation(e)
        {
            if (e.touches && e.touches.length == 1)
            {
                return { x:e.touches[0].clientX, y: e.touches[0].clientY }
            }
            else if (e.clientX && e.clientY)
            {
                return { x: e.clientX, y: e.clientY }        
            }
        }

        let isDragging = false
        let dragStart = { x: 0, y: 0 }

        function onPointerDown(e)
        {
            isDragging = true
            dragStart.x = getEventLocation(e).x/cameraZoom - cameraOffset.x
            dragStart.y = getEventLocation(e).y/cameraZoom - cameraOffset.y
        }

        function onPointerUp(e)
        {
            isDragging = false
            initialPinchDistance = null
            lastZoom = cameraZoom
        }

        function onPointerMove(e)
        {
            if (isDragging)
            {
                cameraOffset.x = getEventLocation(e).x/cameraZoom - dragStart.x
                cameraOffset.y = getEventLocation(e).y/cameraZoom - dragStart.y
            }
        }

        function handleTouch(e, singleTouchHandler)
        {
            if ( e.touches.length == 1 )
            {
                singleTouchHandler(e)
            }
            else if (e.type == "touchmove" && e.touches.length == 2)
            {
                isDragging = false
                handlePinch(e)
            }
        }

        let initialPinchDistance = null
        let lastZoom = cameraZoom

        function handlePinch(e)
        {
            e.preventDefault()
            
            let touch1 = { x: e.touches[0].clientX, y: e.touches[0].clientY }
            let touch2 = { x: e.touches[1].clientX, y: e.touches[1].clientY }
            
            // This is distance squared, but no need for an expensive sqrt as it's only used in ratio
            let currentDistance = (touch1.x - touch2.x)**2 + (touch1.y - touch2.y)**2
            
            if (initialPinchDistance == null)
            {
                initialPinchDistance = currentDistance
            }
            else
            {
                adjustZoom( null, currentDistance/initialPinchDistance )
            }
        }

        function adjustZoom(zoomAmount, zoomFactor)
        {
            if (!isDragging)
            {
                if (zoomAmount)
                {
                    cameraZoom -= zoomAmount
                }
                else if (zoomFactor)
                {
                    console.log(zoomFactor)
                    cameraZoom = zoomFactor*lastZoom
                }
                
                cameraZoom = Math.min( cameraZoom, MAX_ZOOM )
                cameraZoom = Math.max( cameraZoom, MIN_ZOOM )
                
                console.log(zoomAmount)
            }
        }

        canvas.addEventListener('mousedown', onPointerDown)
        canvas.addEventListener('touchstart', (e) => handleTouch(e, onPointerDown))
        canvas.addEventListener('mouseup', onPointerUp)
        canvas.addEventListener('touchend',  (e) => handleTouch(e, onPointerUp))
        canvas.addEventListener('mousemove', onPointerMove)
        canvas.addEventListener('touchmove', (e) => handleTouch(e, onPointerMove))
        canvas.addEventListener( 'wheel', (e) => adjustZoom(e.deltaY*SCROLL_SENSITIVITY))

        // Ready, set, go
        draw()

    </script>
    <form action="/add_device" method="POST">
        <label for="device_id">Device ID:</label><br>
        <input type="text" id="device_id" name="device_id"><br>
        <label for="device_name">Device Name:</label><br>
        <input type="text" id="device_name" name="device_name"><br><br>
        <input type="submit" value="Submit">
    </form>
</div>
</body>
</html>

<style>
    html, body { 
        margin: 0;
        pointer-events:none;
    }
    canvas {
        pointer-events:all;
        position: absolute;
        top: 0;
        left: 0;
        z-index: -1;
    }
    input{
        pointer-events:visible;
    }
    #main{
    }
</style>